---
description: Flutter, Dart, Riverpod, Freezed, Flutter Hooks, Supabase, and Flutter Clean
globs: 
alwaysApply: false
---
    
You are an expert in Flutter, Dart, Riverpod, Freezed, Flutter Hooks, and Supabase.

Key Principles
- Write concise, technical Dart code with accurate examples.
- Use functional and declarative programming patterns where appropriate.
- Prefer composition over inheritance.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported widget, subwidgets, helpers, static content, types.

Dart/Flutter
- Use const constructors for immutable widgets.
- Leverage Freezed for immutable state classes and unions.
- Use arrow syntax for simple functions and methods.
- Prefer expression bodies for one-line getters and setters.
- Use trailing commas for better formatting and diffs.

Error Handling and Validation
- Implement error handling in views using SelectableText.rich instead of SnackBars.
- Display errors in SelectableText.rich with red color for visibility.
- Handle empty states within the displaying screen.
- Use AsyncValue for proper error handling and loading states.

Riverpod-Specific Guidelines
- Use @riverpod annotation for generating providers.
- Prefer AsyncNotifierProvider and NotifierProvider over StateProvider.
- Avoid StateProvider, StateNotifierProvider, and ChangeNotifierProvider.
- Use ref.invalidate() for manually triggering provider updates.
- Implement proper cancellation of asynchronous operations when widgets are disposed.

Performance Optimization
- Use const widgets where possible to optimize rebuilds.
- Implement list view optimizations (e.g., ListView.builder).
- Use AssetImage for static images and cached_network_image for remote images.
- Implement proper error handling for Supabase operations, including network errors.

Key Conventions
1. Use GoRouter or auto_route for navigation and deep linking.
2. Optimize for Flutter performance metrics (first meaningful paint, time to interactive).
3. Prefer stateless widgets:
   - Use ConsumerWidget with Riverpod for state-dependent widgets.
   - Use HookConsumerWidget when combining Riverpod and Flutter Hooks.

UI and Styling
- Use Flutter's built-in widgets and create custom widgets.
- Implement responsive design using LayoutBuilder or MediaQuery.
- Use themes for consistent styling across the app.
- Use Theme.of(context).textTheme.titleLarge instead of headline6, and headlineSmall instead of headline5 etc.

Model and Database Conventions
- Include createdAt, updatedAt, and isDeleted fields in database tables.
- Use @JsonSerializable(fieldRename: FieldRename.snake) for models.
- Implement @JsonKey(includeFromJson: true, includeToJson: false) for read-only fields.

Widgets and UI Components
- Create small, private widget classes instead of methods like Widget _build....
- Implement RefreshIndicator for pull-to-refresh functionality.
- In TextFields, set appropriate textCapitalization, keyboardType, and textInputAction.
- Always include an errorBuilder when using Image.network.

Miscellaneous
- Use log instead of print for debugging.
- Use Flutter Hooks / Riverpod Hooks where appropriate.
- Keep lines no longer than 80 characters, adding commas before closing brackets for multi-parameter functions.
- Use @JsonValue(int) for enums that go to the database.

Code Generation
- Utilize build_runner for generating code from annotations (Freezed, Riverpod, JSON serialization).
- Run 'flutter pub run build_runner build --delete-conflicting-outputs' after modifying annotated classes.

Documentation
- Document complex logic and non-obvious code decisions.
- Follow official Flutter, Riverpod, and Supabase documentation for best practices.

Refer to Flutter, Riverpod, and Supabase documentation for Widgets, State Management, and Backend Integration best practices.

# Riverpod Architecture Guide

## Overview

This document defines architectural best practices and conventions for Flutter projects using **Riverpod** for state management. The goal is to ensure code quality, maintainability, and scalability across teams.

### Why Riverpod?

- **Compile-time safety**: Catches provider access errors at compile time
- **No BuildContext required**: Access providers anywhere in the app
- **Excellent testing**: Easy to override providers for testing
- **Auto-disposal**: Automatic memory management with autoDispose
- **Developer experience**: Great tooling and debugging support
- **Performance**: Fine-grained reactivity and selective rebuilds

---

## Clean Architecture Layers

Even if your folder names do not explicitly use `domain`, `data`, or `presentation`, these layers exist logically in your codebase. Organizing by feature or by layer is both acceptable, as long as you respect the **Dependency Rule**.

### Data Layer ("How")

This layer answers: **How is data fetched or stored?** It contains all implementation details and external dependencies.

**Components:**
- **Repository Implementations:** Concrete classes implementing domain repository interfaces as providers (e.g., `authRepositoryProvider`)
- **Data Sources:** Provider-based classes responsible for interacting with a single data source (e.g., `userRemoteDataSourceProvider`, `userLocalDataSourceProvider`)
- **DTOs (Data Transfer Objects):** Models for parsing and serializing data from APIs (e.g., `UserDto`)
- **Dependencies:** Uses packages like Dio, Hive, etc. No other layer depends on Data (except for DI setup)

### Domain Layer ("What")

This layer answers: **What can the app do?** It is the core of your business logic and is independent of frameworks and tools.

**Components:**
- **Entities:** Pure Dart objects representing core business concepts (e.g., `User`)
- **Repository Interfaces:** Abstract classes defining contracts for data access (e.g., `abstract class AuthRepository`)
- **Use Cases:** Provider-based classes encapsulating specific business actions (e.g., `loginUseCaseProvider`). In small/medium apps, UI providers may call repository methods directly instead of separate use cases
- **Dependencies:** No dependencies on other layers or frameworks

### Presentation Layer ("Show")

This layer answers: **What is displayed and how does the user interact?**

**Components:**
- **UI (Views):** Widgets and pages using `ConsumerWidget` or `HookConsumerWidget`
- **State Management:** StateNotifierProvider, Provider, and their States. Providers interact with the Domain layer and expose state to the UI

### Example Folder Structure (Feature-Based)

```text
lib/
├── features/
│   ├── auth/
│   │   ├── data/
│   │   │   ├── datasources/
│   │   │   ├── models/
│   │   │   ├── providers/
│   │   │   └── repositories/
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── providers/
│   │   │   ├── repositories/
│   │   │   └── usecases/
│   │   └── presentation/
│   │       ├── notifiers/
│   │       ├── providers/
│   │       ├── pages/
│   │       └── widgets/
│   └── home/
│       ├── data/
│       ├── domain/
│       └── presentation/
└── shared/
    ├── data/
    ├── domain/
    └── presentation/
```

### Dependency Rule

The most important rule is to respect the **Dependency Rule**:

**Presentation → Domain ← Data**

This ensures a clean, maintainable architecture regardless of folder naming:
- **Presentation layer** can depend on Domain layer
- **Data layer** can depend on Domain layer  
- **Domain layer** cannot depend on any other layer
- **Data and Presentation** layers cannot depend on each other directly

---
# Riverpod Conventions & Organization

## Naming Conventions

### Provider Names
- **Provider variables**: camelCase, suffix with `Provider` (e.g., `authRepositoryProvider`, `userProfileProvider`)
- **StateNotifierProvider**: camelCase, suffix with `Provider` (e.g., `loginNotifierProvider`, `userListNotifierProvider`)
- **FutureProvider**: camelCase, describe what it provides (e.g., `currentUserProvider`, `userListProvider`)
- **StreamProvider**: camelCase, suffix with `StreamProvider` (e.g., `authStateStreamProvider`, `messagesStreamProvider`)

### Class Names
- **StateNotifier classes**: PascalCase, suffix with `Notifier` (e.g., `LoginNotifier`, `UserProfileNotifier`)
- **State classes**: PascalCase, suffix with `State` (e.g., `LoginState`, `UserProfileState`)
- **Repository classes**: PascalCase, suffix with `Repository` (e.g., `AuthRepository`, `UserRepository`)
- **Use case classes**: PascalCase, suffix with `UseCase` (e.g., `LoginUseCase`, `GetUserUseCase`)

### Files
- **Provider files**: snake_case, suffix with `_providers` (e.g., `auth_providers.dart`, `user_providers.dart`)
- **Notifier files**: snake_case, suffix with `_notifier` (e.g., `login_notifier.dart`, `user_profile_notifier.dart`)
- **State files**: snake_case, suffix with `_state` (e.g., `login_state.dart`, `user_profile_state.dart`)
- **Test files**: Add `_test` suffix (e.g., `login_notifier_test.dart`)
- **Mock files**: Add `_mock` suffix (e.g., `auth_repository_mock.dart`)

### Folders
- **Features**: snake_case (e.g., `user_profile`, `shopping_cart`)
- **Layers**: lowercase (e.g., `data`, `domain`, `presentation`)
- **Components**: lowercase plural (e.g., `providers`, `notifiers`, `widgets`, `pages`)

### Examples

```dart
// ✅ Good naming
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

final authRepositoryProvider = Provider.autoDispose<AuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});

final currentUserProvider = FutureProvider.autoDispose<User>((ref) {
  return ref.read(authRepositoryProvider).getCurrentUser();
});

// ❌ Bad naming
final login = StateNotifierProvider<LoginNotifier, LoginData>((ref) {
  return LoginNotifier(ref.read(authRepo));
});

final auth_repository = Provider<AuthRepo>((ref) {
  return AuthRepoImpl(ref.read(restClient));
});
```

---

## File & Directory Organization

### Feature-First

**Feature-First:**
```
lib/
├── features/
│   ├── auth/
│   │   ├── data/
│   │   ├── domain/
│   │   └── presentation/
│   └── dashboard/
│       ├── data/
│       ├── domain/
│       └── presentation/
└── shared/
    ├── data/
    ├── domain/
    └── presentation/
```

### File Organization Best Practices

1. **Separate provider files**: Group related providers in dedicated files
2. **Logical grouping**: Group related files in folders
3. **Test placement**: Mirror production structure in `test/` folder
4. **Barrel exports**: Use `index.dart` files for easier imports

```dart
// lib/features/auth/auth.dart (barrel file)
export 'data/providers/auth_data_providers.dart';
export 'domain/providers/auth_domain_providers.dart';
export 'presentation/providers/auth_ui_providers.dart';
export 'presentation/notifiers/login_notifier.dart';
export 'presentation/notifiers/login_state.dart';
export 'presentation/pages/login_page.dart';
```

### Provider File Organization

```dart
// lib/features/auth/presentation/providers/auth_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// UI State Providers
final obscurePasswordProvider = StateProvider.autoDispose<bool>((ref) => true);

final loginFormProvider = StateProvider.autoDispose<LoginFormData>((ref) {
  return LoginFormData.empty();
});

// Notifier Providers
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(
    authRepository: ref.read(authRepositoryProvider),
    analytics: ref.read(analyticsProvider),
  );
});

// Computed Providers
final isLoginFormValidProvider = Provider.autoDispose<bool>((ref) {
  final formData = ref.watch(loginFormProvider);
  return formData.email.isNotEmpty && formData.password.length >= 6;
});

// Future Providers
final currentUserProvider = FutureProvider.autoDispose<User?>((ref) {
  return ref.read(authRepositoryProvider).getCurrentUser();
});
```

---

## Provider Types & Usage

### Provider Type Guidelines

**Use `Provider` for:**
- Immutable services (repositories, use cases)
- Configuration objects
- Computed values that don't change often

```dart
final configProvider = Provider<AppConfig>((ref) {
  return AppConfig();
});

final authRepositoryProvider = Provider.autoDispose<AuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});
```

**Use `StateProvider` for:**
- Simple mutable state
- UI flags and toggles
- Form field values

```dart
final counterProvider = StateProvider<int>((ref) => 0);

final obscurePasswordProvider = StateProvider.autoDispose<bool>((ref) => true);

final selectedTabProvider = StateProvider<int>((ref) => 0);
```

**Use `StateNotifierProvider` for:**
- Complex state management
- Business logic with multiple state transitions
- Features requiring side effects

```dart
final userListNotifierProvider = StateNotifierProvider.autoDispose<UserListNotifier, UserListState>((ref) {
  return UserListNotifier(ref.read(userRepositoryProvider));
});
```

**Use `FutureProvider` for:**
- Async data that loads once
- API calls without complex state
- Data transformation

```dart
final userListProvider = FutureProvider.autoDispose<List<User>>((ref) {
  return ref.read(userRepositoryProvider).getUsers();
});

final userByIdProvider = FutureProvider.family.autoDispose<User, String>((ref, userId) {
  return ref.read(userRepositoryProvider).getUserById(userId);
});
```

**Use `StreamProvider` for:**
- Continuous data streams
- WebSocket connections
- Real-time updates

```dart
final authStateStreamProvider = StreamProvider<AuthState>((ref) {
  return ref.read(authServiceProvider).authStateStream;
});

final messagesStreamProvider = StreamProvider.family.autoDispose<List<Message>, String>((ref, chatId) {
  return ref.read(messageServiceProvider).getMessagesStream(chatId);
});
```

### AutoDispose Guidelines

**Use `autoDispose` for:**
- Feature-specific providers
- UI state that should reset when leaving screen
- Providers with expensive resources

```dart
// ✅ Good: Feature-specific state
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

// ✅ Good: UI state
final searchQueryProvider = StateProvider.autoDispose<String>((ref) => '');
```

**Don't use `autoDispose` for:**
- Global app state
- Shared services
- Configuration providers

```dart
// ✅ Good: Global services
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});

// ✅ Good: App configuration
final appConfigProvider = Provider<AppConfig>((ref) {
  return AppConfig();
});
```

---

## Dependency Injection

### Manual Dependency Injection

For simple projects, use manual provider registration:

```dart
// lib/core/providers/app_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Infrastructure
final restClientProvider = Provider<RestClient>((ref) {
  return RestClient();
});

final localStorageProvider = Provider<LocalStorage>((ref) {
  return HiveLocalStorage();
});

// Repositories
final authRepositoryProvider = Provider.autoDispose<AuthRepository>((ref) {
  return AuthRepositoryImpl(
    restClient: ref.read(restClientProvider),
    localStorage: ref.read(localStorageProvider),
  );
});

final userRepositoryProvider = Provider.autoDispose<UserRepository>((ref) {
  return UserRepositoryImpl(
    restClient: ref.read(restClientProvider),
    localStorage: ref.read(localStorageProvider),
  );
});

// Use Cases
final loginUseCaseProvider = Provider.autoDispose<LoginUseCase>((ref) {
  return LoginUseCase(ref.read(authRepositoryProvider));
});
```

### Provider Overrides

For testing or different implementations:

```dart
// In main.dart
final overrides = [
  restClientProvider.overrideWith((ref) => MockRestClient()),
  localStorageProvider.overrideWith((ref) => MockLocalStorage()),
];

runApp(ProviderScope(
  overrides: overrides,
  child: MyApp(),
));

// In tests
testWidgets('should work correctly', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        authRepositoryProvider.overrideWith((ref) => MockAuthRepository()),
        userRepositoryProvider.overrideWith((ref) => MockUserRepository()),
      ],
      child: MyApp(),
    ),
  );
});
```

### Module-Based Organization

For larger projects, organize providers by modules:

```dart
// lib/features/auth/providers/auth_module.dart
class AuthModule {
  static final providers = [
    authRepositoryProvider,
    loginUseCaseProvider,
    loginNotifierProvider,
  ];
  
  static final overrides = <Override>[];
}

// lib/features/user/providers/user_module.dart
class UserModule {
  static final providers = [
    userRepositoryProvider,
    userListNotifierProvider,
    userProfileNotifierProvider,
  ];
}

// In main.dart
final allOverrides = [
  ...AuthModule.overrides,
  ...UserModule.overrides,
];

runApp(ProviderScope(
  overrides: allOverrides,
  child: MyApp(),
));
```

### Cross-Module Dependencies

- Shared providers are defined in `shared/providers/`
- Feature modules import shared providers as needed
- Use provider overrides for testing cross-module interactions

```dart
// shared/providers/shared_providers.dart
final restClientProvider = Provider<RestClient>((ref) {
  return RestClient();
});

final analyticsProvider = Provider<Analytics>((ref) {
  return FirebaseAnalytics();
});

// feature/auth/providers/auth_providers.dart
import 'package:shared/providers/shared_providers.dart';

final authRepositoryProvider = Provider.autoDispose<AuthRepository>((ref) {
  return AuthRepositoryImpl(
    restClient: ref.read(restClientProvider), // Shared dependency
    analytics: ref.read(analyticsProvider), // Shared dependency
  );
});
```

### Provider Lifecycle Management

- Use `keepAlive()` to prevent auto-disposal when needed
- Use `ref.invalidate()` to force provider refresh
- Always clean up resources in StateNotifier

```dart
// Prevent auto-disposal conditionally
final userCacheProvider = FutureProvider.autoDispose<List<User>>((ref) {
  final users = await fetchUsers();
  
  // Keep alive if users are loaded
  if (users.isNotEmpty) {
    ref.keepAlive();
  }
  
  return users;
});

// Force refresh
ref.invalidate(userListProvider);

// Clean up in StateNotifier
class UserListNotifier extends StateNotifier<UserListState> {
  StreamSubscription? _subscription;
  
  UserListNotifier(this._repository) : super(UserListState.initial()) {
    _subscription = _repository.userStream.listen(_updateUsers);
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}
``` 
# Riverpod Development Practices

## Networking & Error Handling

### Repository with Error Handling

```dart
final apiServiceProvider = Provider<ApiService>((ref) {
  return ApiService();
});

final userRepositoryProvider = Provider.autoDispose<UserRepository>((ref) {
  return UserRepositoryImpl(ref.read(apiServiceProvider));
});

class UserRepositoryImpl implements UserRepository {
  final ApiService _apiService;
  UserRepositoryImpl(this._apiService);

  @override
  Future<Result<User>> getUser(String id) async {
    try {
      final response = await _apiService.dio.get('/users/$id');
      final user = User.fromJson(response.data);
      return Result.success(data: user);
    } on DioException catch (e) {
      return Result.failure(error: _handleDioError(e));
    } catch (e) {
      return Result.failure(error: AppException('Unexpected error: $e'));
    }
  }
}
```

### StateNotifier with Error Handling

```dart
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  return UserNotifier(ref.read(userRepositoryProvider));
});

class UserNotifier extends StateNotifier<UserState> {
  final UserRepository _repository;
  
  UserNotifier(this._repository) : super(UserState.initial());

  Future<void> loadUser(String id) async {
    state = state.copyWith(isLoading: true, error: null);
    
    final result = await _repository.getUser(id);
    
    result.when(
      success: (user) => state = state.copyWith(
        isLoading: false,
        user: user,
      ),
      failure: (error) => state = state.copyWith(
        isLoading: false,
        error: error.message,
      ),
    );
  }
}
```

---

## Testing

### Unit Testing Providers

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

void main() {
  group('UserNotifier', () {
    late ProviderContainer container;
    late MockUserRepository mockRepository;

    setUp(() {
      mockRepository = MockUserRepository();
      container = ProviderContainer(
        overrides: [
          userRepositoryProvider.overrideWith((ref) => mockRepository),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('should load user successfully', () async {
      // Given
      const userId = '123';
      final mockUser = User(id: userId, name: 'Test User');
      when(() => mockRepository.getUser(userId))
          .thenAnswer((_) async => Result.success(data: mockUser));

      // When
      final notifier = container.read(userNotifierProvider.notifier);
      await notifier.loadUser(userId);

      // Then
      final state = container.read(userNotifierProvider);
      expect(state.user, equals(mockUser));
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
    });
  });
}
```

### Widget Testing with Riverpod

```dart
testWidgets('should display user data correctly', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        userRepositoryProvider.overrideWith((ref) => MockUserRepository()),
      ],
      child: MaterialApp(home: UserPage()),
    ),
  );

  // Test implementation
  expect(find.text('Test User'), findsOneWidget);
});
```

---

## Performance Optimization

### Selective Watching

```dart
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ❌ Bad: Watches entire state
    final userState = ref.watch(userNotifierProvider);
    
    // ✅ Good: Watches only specific field
    final isLoading = ref.watch(userNotifierProvider.select((state) => state.isLoading));
    final userName = ref.watch(userNotifierProvider.select((state) => state.user?.name));
    
    return Column(
      children: [
        if (isLoading) CircularProgressIndicator(),
        if (userName != null) Text(userName),
      ],
    );
  }
}
```

### Provider Granularity

```dart
// ✅ Good: Focused providers
final userNameProvider = Provider.autoDispose<String?>((ref) {
  return ref.watch(userNotifierProvider.select((state) => state.user?.name));
});

final userLoadingProvider = Provider.autoDispose<bool>((ref) {
  return ref.watch(userNotifierProvider.select((state) => state.isLoading));
});
```

---

## Best Practices

### State Structure with Freezed

```dart
@freezed
class UserState with _$UserState {
  const factory UserState({
    @Default(false) bool isLoading,
    @Default(null) User? user,
    @Default(null) String? error,
  }) = _UserState;
  
  factory UserState.initial() => const UserState();
}
```

### Error Handling Pattern

```dart
class UserNotifier extends StateNotifier<UserState> {
  UserNotifier(this._repository) : super(UserState.initial());

  Future<void> loadUser(String id) async {
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      final user = await _repository.getUser(id);
      state = state.copyWith(isLoading: false, user: user);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }
}
```

### Provider Dependencies

```dart
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  final repository = ref.watch(userRepositoryProvider);
  final analytics = ref.read(analyticsProvider);
  
  return UserNotifier(repository, analytics);
});
```

### Cleanup Resources

```dart
class UserNotifier extends StateNotifier<UserState> {
  StreamSubscription? _subscription;
  
  UserNotifier(this._repository) : super(UserState.initial()) {
    _subscription = _repository.userStream.listen(_updateUser);
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
} 

# Riverpod State Management Guide

## State Management with StateNotifier & Freezed


```dart
@freezed
class LoginState with _$LoginState {
  const factory LoginState({
    @Default(LoginStatus.initial) LoginStatus status,
    @Default(null) String? error,
    @Default(null) User? user,
    @Default(false) bool isLoading,
    @Default(true) bool obscurePassword,
  }) = _LoginState;

  factory LoginState.initial() => const LoginState();
  
  const LoginState._();
  bool get isAuthenticated => user != null;
  bool get hasError => error != null;
}
```

### StateNotifier Implementation

```dart
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

class LoginNotifier extends StateNotifier<LoginState> {
  final AuthRepository _authRepository;

  LoginNotifier(this._authRepository) : super(LoginState.initial());

  Future<void> login(String email, String password) async {
    if (email.isEmpty || password.isEmpty) {
      state = state.copyWith(
        status: LoginStatus.failure,
        error: 'Email and password cannot be empty',
      );
      return;
    }

    state = state.copyWith(status: LoginStatus.loading, isLoading: true);

    try {
      final user = await _authRepository.login(email, password);
      state = state.copyWith(
        status: LoginStatus.success,
        user: user,
        error: null,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        status: LoginStatus.failure,
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void togglePasswordVisibility() {
    state = state.copyWith(obscurePassword: !state.obscurePassword);
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}
```

---

## Hook Usage Guidelines

### Hook Organization in build() Method

```dart
class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Form hooks
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final formKey = useMemoized(() => GlobalKey<FormState>());
    
    // 2. State hooks
    final focusNode = useFocusNode();
    
    // 3. Effect hooks
    useEffect(() {
      // Side effect logic
      return null;
    }, []);
    
    // 4. Riverpod providers
    final loginState = ref.watch(loginNotifierProvider);
    final loginNotifier = ref.read(loginNotifierProvider.notifier);
    
    // 5. Computed values
    final isFormValid = useMemoized(() {
      return emailController.text.isNotEmpty && 
             passwordController.text.length >= 6;
    }, [emailController.text, passwordController.text]);
    
    // 6. Listen for side effects
    ref.listen<LoginState>(loginNotifierProvider, (previous, next) {
      if (next.status == LoginStatus.success) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => HomePage()),
        );
      }
    });
    
    return Scaffold(
      body: Form(
        key: formKey,
        child: Column(
          children: [
            TextFormField(
              controller: emailController,
              focusNode: focusNode,
            ),
            TextFormField(
              controller: passwordController,
              obscureText: loginState.obscurePassword,
            ),
            ElevatedButton(
              onPressed: isFormValid ? () {
                loginNotifier.login(
                  emailController.text,
                  passwordController.text,
                );
              } : null,
              child: Text('Login'),
            ),
          ],
        ),
      ),
    );
  }
}
```

### Avoid Unnecessary Function Parameters

```dart
// ✅ Good: Direct closure usage
class MyWidget extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController();
    final theme = Theme.of(context);
    
    Widget _buildHeader() {
      return Container(
        color: theme.primaryColor,
        child: TextField(controller: controller),
      );
    }
    
    return Scaffold(body: _buildHeader());
  }
}
```

---

## State Patterns

### Loading States

```dart
@freezed
class AsyncState<T> with _$AsyncState<T> {
  const factory AsyncState.loading() = AsyncLoading<T>;
  const factory AsyncState.data(T value) = AsyncData<T>;
  const factory AsyncState.error(String message) = AsyncError<T>;
}

class UserListNotifier extends StateNotifier<AsyncState<List<User>>> {
  UserListNotifier(this._repository) : super(const AsyncState.loading());

  Future<void> loadUsers() async {
    state = const AsyncState.loading();
    
    try {
      final users = await _repository.getUsers();
      state = AsyncState.data(users);
    } catch (e) {
      state = AsyncState.error(e.toString());
    }
  }
}
```

### Form State Pattern

```dart
@freezed
class FormState<T> with _$FormState<T> {
  const factory FormState({
    @Default(false) bool isSubmitting,
    @Default(null) T? data,
    @Default({}) Map<String, String> errors,
    @Default(null) String? submitError,
  }) = _FormState<T>;
  
  const FormState._();
  bool get hasErrors => errors.isNotEmpty;
  bool get isValid => !hasErrors && data != null;
}
```

---

## Error Handling in State

### Global Error Handling

```dart
final errorNotifierProvider = StateNotifierProvider<ErrorNotifier, ErrorState>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<ErrorState> {
  ErrorNotifier() : super(ErrorState.initial());

  void showError(String message) {
    state = state.copyWith(error: message, hasError: true);
  }

  void clearError() {
    state = state.copyWith(error: null, hasError: false);
  }
}

// Usage in other notifiers
class UserNotifier extends StateNotifier<UserState> {
  final Ref _ref;
  
  UserNotifier(this._ref, this._repository) : super(UserState.initial());

  Future<void> loadUser() async {
    try {
      // ... load user logic
    } catch (e) {
      _ref.read(errorNotifierProvider.notifier).showError(e.toString());
    }
  }
}
```

### Result Pattern

```dart
@freezed
class Result<T> with _$Result<T> {
  const factory Result.success({required T data}) = Success<T>;
  const factory Result.failure({required String error}) = Failure<T>;
}

// Usage
Future<Result<User>> login(String email, String password) async {
  try {
    final user = await _authRepository.login(email, password);
    return Result.success(data: user);
  } catch (e) {
    return Result.failure(error: e.toString());
  }
}
``` 
# Riverpod Tooling & Configuration


## Recommended Packages

```yaml
environment:
   sdk: ^3.8.0  

dependencies:
  freezed: ^3.2.0
  freezed_annotation: ^3.1.0
  equatable: ^2.0.5

  #state management
  flutter_riverpod: ^3.0.0
  riverpod_annotation: ^3.0.0

  #hooks
  flutter_hooks: ^0.21.3+1
  hooks_riverpod: ^3.0.0

dev_dependencies:
  json_serializable: ^6.11.0

  build_runner: ^2.7.1
  freezed: ^3.2.0

  #envied generator
  envied_generator: ^1.2.1
  
  #injectable generator
  injectable_generator: ^2.6.2

  #riverpod generator
  riverpod_generator: ^3.0.0

  #riverpod lint
  riverpod_lint: ^3.0.0


  #test
  mockito: ^5.5.0
```

---

## Configuration Management

### Environment Configuration with Riverpod

```dart
// Abstract configuration
abstract class AppConfig {
  String get apiBaseUrl;
  String get apiKey;
  bool get enableLogging;
}

// Configuration provider
final appConfigProvider = Provider<AppConfig>((ref) {
  const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'dev');
  
  switch (environment) {
    case 'prod':
      return ProdAppConfig();
    case 'staging':
      return StagingAppConfig();
    default:
      return DevAppConfig();
  }
});

// Development configuration
class DevAppConfig implements AppConfig {
  @override
  String get apiBaseUrl => 'https://dev-api.example.com';
  
  @override
  String get apiKey => 'dev_api_key';
  
  @override
  bool get enableLogging => true;
}
```

### Provider-based DI Container

```dart
// Core providers
final dioProvider = Provider<Dio>((ref) {
  final config = ref.read(appConfigProvider);
  return Dio(BaseOptions(
    baseUrl: config.apiBaseUrl,
    headers: {'Authorization': 'Bearer ${config.apiKey}'},
  ));
});

final localStorageProvider = Provider<LocalStorage>((ref) {
  return HiveLocalStorage();
});

// Repository providers
final authRepositoryProvider = Provider.autoDispose<AuthRepository>((ref) {
  return AuthRepositoryImpl(
    dio: ref.read(dioProvider),
    localStorage: ref.read(localStorageProvider),
  );
});
```

---

## Flutter App Flavors

### Flavor-based Provider Overrides

```dart
// main_dev.dart
void main() {
  runApp(
    ProviderScope(
      overrides: [
        appConfigProvider.overrideWith((ref) => DevAppConfig()),
      ],
      child: MyApp(),
    ),
  );
}

// main_prod.dart
void main() {
  runApp(
    ProviderScope(
      overrides: [
        appConfigProvider.overrideWith((ref) => ProdAppConfig()),
      ],
      child: MyApp(),
    ),
  );
}
```

### Feature Flags with Riverpod

```dart
final featureFlagsProvider = Provider<FeatureFlags>((ref) {
  final config = ref.read(appConfigProvider);
  return FeatureFlags(
    enableNewUI: config.enableNewUI,
    enableAnalytics: config.enableAnalytics,
  );
});

final shouldShowNewUIProvider = Provider<bool>((ref) {
  return ref.read(featureFlagsProvider).enableNewUI;
});

// Usage in widgets
class HomePage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final showNewUI = ref.watch(shouldShowNewUIProvider);
    
    return showNewUI ? NewHomePage() : LegacyHomePage();
  }
}
```

---

## Common Scenarios & Solutions

### Caching with Riverpod

```dart
final userCacheProvider = StateNotifierProvider<UserCacheNotifier, Map<String, User>>((ref) {
  return UserCacheNotifier();
});

final userByIdProvider = FutureProvider.family.autoDispose<User, String>((ref, userId) async {
  final cache = ref.read(userCacheProvider);
  
  // Return cached user if available
  if (cache.containsKey(userId)) {
    return cache[userId]!;
  }
  
  // Fetch from repository
  final repository = ref.read(userRepositoryProvider);
  final user = await repository.getUserById(userId);
  
  // Cache the result
  ref.read(userCacheProvider.notifier).cacheUser(user);
  
  return user;
});
```

### Debounced Search

```dart
final searchQueryProvider = StateProvider<String>((ref) => '');

final debouncedSearchProvider = Provider<String>((ref) {
  final query = ref.watch(searchQueryProvider);
  final debouncer = ref.keepAlive();
  
  Timer? timer;
  timer?.cancel();
  
  timer = Timer(Duration(milliseconds: 500), () {
    debouncer.close();
  });
  
  ref.onDispose(() => timer?.cancel());
  
  return query;
});

final searchResultsProvider = FutureProvider.autoDispose<List<User>>((ref) {
  final query = ref.watch(debouncedSearchProvider);
  
  if (query.isEmpty) return [];
  
  return ref.read(userRepositoryProvider).searchUsers(query);
});
```

### Pagination

```dart
@freezed
class PaginatedState<T> with _$PaginatedState<T> {
  const factory PaginatedState({
    @Default([]) List<T> items,
    @Default(false) bool isLoading,
    @Default(false) bool hasMore,
    @Default(null) String? error,
  }) = _PaginatedState<T>;
}

final userListNotifierProvider = StateNotifierProvider.autoDispose<UserListNotifier, PaginatedState<User>>((ref) {
  return UserListNotifier(ref.read(userRepositoryProvider));
});

class UserListNotifier extends StateNotifier<PaginatedState<User>> {
  final UserRepository _repository;
  int _currentPage = 0;

  UserListNotifier(this._repository) : super(PaginatedState<User>());

  Future<void> loadMore() async {
    if (state.isLoading || !state.hasMore) return;
    
    state = state.copyWith(isLoading: true);
    
    try {
      final newUsers = await _repository.getUsers(page: _currentPage);
      
      state = state.copyWith(
        items: [...state.items, ...newUsers],
        isLoading: false,
        hasMore: newUsers.isNotEmpty,
      );
      
      _currentPage++;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
}
```

---

## Common Anti-Patterns to Avoid

### ❌ Don't Access Providers in Constructors

```dart
// ❌ Bad
class UserNotifier extends StateNotifier<UserState> {
  UserNotifier(WidgetRef ref) : super(UserState.initial()) {
    // Don't do this!
    final repository = ref.read(userRepositoryProvider);
  }
}

// ✅ Good
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  return UserNotifier(ref.read(userRepositoryProvider));
});
```

### ❌ Don't Use ref.read in build()

```dart
// ❌ Bad
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.read(userProvider); // Won't rebuild!
    return Text(user.name);
  }
}

// ✅ Good
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(userProvider); // Will rebuild
    return Text(user.name);
  }
}
```

### ❌ Don't Forget autoDispose

```dart
// ❌ Bad: Memory leak
final userListProvider = StateNotifierProvider<UserListNotifier, UserListState>((ref) {
  return UserListNotifier();
});

// ✅ Good: Auto-disposed
final userListProvider = StateNotifierProvider.autoDispose<UserListNotifier, UserListState>((ref) {
  return UserListNotifier();
});
```

### ❌ Don't Overuse StateProvider

```dart
// ❌ Bad: Complex state in StateProvider
final userStateProvider = StateProvider<Map<String, dynamic>>((ref) => {});

// ✅ Good: Use StateNotifier for complex state
final userNotifierProvider = StateNotifierProvider<UserNotifier, UserState>((ref) {
  return UserNotifier();
});
``` 
