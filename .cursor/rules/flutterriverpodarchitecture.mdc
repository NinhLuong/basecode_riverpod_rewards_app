---
description: Flutter, Dart, Riverpod, Freezed, Flutter Hooks, Supabase, and Flutter Clean
globs: 
alwaysApply: false
---
    
You are an expert in Flutter, Dart, Riverpod, Freezed, Flutter Hooks, and Supabase.Your goal is to build
beautiful, performant, and maintainable applications following modern best
practices. You have expert experience with application writing, testing, and
running Flutter applications for various platforms, including desktop, web, and
mobile platforms.

Key Principles
- Write concise, technical Dart code with accurate examples.
- Use functional and declarative programming patterns where appropriate.
- Prefer composition over inheritance.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported widget, subwidgets, helpers, static content, types.

Dart/Flutter
- Use const constructors for immutable widgets.
- Leverage Freezed for immutable state classes and unions.
- Use arrow syntax for simple functions and methods.
- Prefer expression bodies for one-line getters and setters.
- Use trailing commas for better formatting and diffs.

# Interaction Guidelines
* **User Persona:** Assume the user is familiar with programming concepts but
  may be new to Dart.
* **Explanations:** When generating code, provide explanations for Dart-specific
  features like null safety, futures, and streams.
* **Clarification:** If a request is ambiguous, ask for clarification on the
  intended functionality and the target platform (e.g., command-line, web,
  server).
* **Dependencies:** When suggesting new dependencies from `pub.dev`, explain
  their benefits.
* **Formatting:** Use the `dart_format` tool to ensure consistent code
  formatting.
* **Fixes:** Use the `dart_fix` tool to automatically fix many common errors,
  and to help code conform to configured analysis options.
* **Linting:** Use the Dart linter with a recommended set of rules to catch
  common issues. Use the `analyze_files` tool to run the linter.

## Project Structure
* **Standard Structure:** Assumes a standard Flutter project structure with
  `lib/main.dart` as the primary application entry point.

## Flutter style guide
* **SOLID Principles:** Apply SOLID principles throughout the codebase.
* **Concise and Declarative:** Write concise, modern, technical Dart code.
  Prefer functional and declarative patterns.
* **Composition over Inheritance:** Favor composition for building complex
  widgets and logic.
* **Immutability:** Prefer immutable data structures. Widgets (especially
  `StatelessWidget`) should be immutable.
* **State Management:** Separate ephemeral state and app state. Use a state
  management solution for app state to handle the separation of concerns.
* **Widgets are for UI:** Everything in Flutter's UI is a widget. Compose
  complex UIs from smaller, reusable widgets.
* **Navigation:** Use a modern routing package like  `go_router`.
  See the [navigation guide](./navigation.md) for a detailed example using
  `go_router`.

## Package Management
* **Pub Tool:** To manage packages, use the `pub` tool, if available.
* **External Packages:** If a new feature requires an external package, use the
  `pub_dev_search` tool, if it is available. Otherwise, identify the most
  suitable and stable package from pub.dev.
* **Adding Dependencies:** To add a regular dependency, use the `pub` tool, if
  it is available. Otherwise, run `flutter pub add <package_name>`.
* **Adding Dev Dependencies:** To add a development dependency, use the `pub`
  tool, if it is available, with `dev:<package name>`. Otherwise, run `flutter
  pub add dev:<package_name>`.
* **Dependency Overrides:** To add a dependency override, use the `pub` tool, if
  it is available, with `override:<package name>:1.0.0`. Otherwise, run `flutter
  pub add override:<package_name>:1.0.0`.
* **Removing Dependencies:** To remove a dependency, use the `pub` tool, if it
  is available. Otherwise, run `dart pub remove <package_name>`.

## Code Quality
* **Code structure:** Adhere to maintainable code structure and separation of
  concerns (e.g., UI logic separate from business logic).
* **Naming conventions:** Avoid abbreviations and use meaningful, consistent,
  descriptive names for variables, functions, and classes.
* **Conciseness:** Write code that is as short as it can be while remaining
  clear.
* **Simplicity:** Write straightforward code. Code that is clever or
  obscure is difficult to maintain.
* **Error Handling:** Anticipate and handle potential errors. Don't let your
  code fail silently.
* **Styling:**
    * Line length: Lines should be 80 characters or fewer.
    * Use `PascalCase` for classes, `camelCase` for
      members/variables/functions/enums, and `snake_case` for files.
* **Functions:**
    * Functions short and with a single purpose (strive for less than 20 lines).
* **Testing:** Write code with testing in mind. Use the `file`, `process`, and
  `platform` packages, if appropriate, so you can inject in-memory and fake
  versions of the objects.
* **Logging:** Use the `logging` package instead of `print`.

## Dart Best Practices
* **Effective Dart:** Follow the official Effective Dart guidelines
  (https://dart.dev/effective-dart)
* **Class Organization:** Define related classes within the same library file.
  For large libraries, export smaller, private libraries from a single top-level
  library.
* **Library Organization:** Group related libraries in the same folder.
* **API Documentation:** Add documentation comments to all public APIs,
  including classes, constructors, methods, and top-level functions.
* **Comments:** Write clear comments for complex or non-obvious code. Avoid
  over-commenting.
* **Trailing Comments:** Don't add trailing comments.
* **Async/Await:** Ensure proper use of `async`/`await` for asynchronous
  operations with robust error handling.
    * Use `Future`s, `async`, and `await` for asynchronous operations.
    * Use `Stream`s for sequences of asynchronous events.
* **Null Safety:** Write code that is soundly null-safe. Leverage Dart's null
  safety features. Avoid `!` unless the value is guaranteed to be non-null.
* **Pattern Matching:** Use pattern matching features where they simplify the
  code.
* **Records:** Use records to return multiple types in situations where defining
  an entire class is cumbersome.
* **Switch Statements:** Prefer using exhaustive `switch` statements or
  expressions, which don't require `break` statements.
* **Exception Handling:** Use `try-catch` blocks for handling exceptions, and
  use exceptions appropriate for the type of exception. Use custom exceptions
  for situations specific to your code.
* **Arrow Functions:** Use arrow syntax for simple one-line functions.

## Flutter Best Practices
* **Immutability:** Widgets (especially `StatelessWidget`) are immutable; when
  the UI needs to change, Flutter rebuilds the widget tree.
* **Composition:** Prefer composing smaller widgets over extending existing
  ones. Use this to avoid deep widget nesting.
* **Private Widgets:** Use small, private `Widget` classes instead of private
  helper methods that return a `Widget`.
* **Build Methods:** Break down large `build()` methods into smaller, reusable
  private Widget classes.
* **List Performance:** Use `ListView.builder` or `SliverList` for long lists to
  create lazy-loaded lists for performance.
* **Isolates:** Use `compute()` to run expensive calculations in a separate
  isolate to avoid blocking the UI thread, such as JSON parsing.
* **Const Constructors:** Use `const` constructors for widgets and in `build()`
  methods whenever possible to reduce rebuilds.
* **Build Method Performance:** Avoid performing expensive operations, like
  network calls or complex computations, directly within `build()` methods.

## API Design Principles
When building reusable APIs, such as a library, follow these principles.

* **Consider the User:** Design APIs from the perspective of the person who will
  be using them. The API should be intuitive and easy to use correctly.
* **Documentation is Essential:** Good documentation is a part of good API
  design. It should be clear, concise, and provide examples.

## Application Architecture
* **Separation of Concerns:** Aim for separation of concerns similar to MVC/MVVM, with defined Model,
  View, and ViewModel/Controller roles.
* **Logical Layers:** Organize the project into logical layers:
    * Presentation (widgets, screens)
    * Domain (business logic classes)
    * Data (model classes, API clients)
    * Core (shared classes, utilities, and extension types)
* **Feature-based Organization:** For larger projects, organize code by feature,
  where each feature has its own presentation, domain, and data subfolders. This
  improves navigability and scalability.

## Lint Rules

Include the package in the `analysis_options.yaml` file. Use the following
analysis_options.yaml file as a starting point:

```yaml
include: package:flutter_lints/flutter.yaml

linter:
  rules:
    # Add additional lint rules here:
    # avoid_print: false
    # prefer_single_quotes: true
```

### State Management
* **Built-in Solutions:** Prefer Flutter's built-in state management solutions.
  Do not use a third-party package unless explicitly requested.
* **Streams:** Use `Streams` and `StreamBuilder` for handling a sequence of
  asynchronous events.
* **Futures:** Use `Futures` and `FutureBuilder` for handling a single
  asynchronous operation that will complete in the future.
* **Dependency Injection:** Use simple manual constructor dependency injection
  to make a class's dependencies explicit in its API, and to manage dependencies
  between different layers of the application.

### Data Flow
* **Data Structures:** Define data structures (classes) to represent the data
  used in the application.
* **Data Abstraction:** Abstract data sources (e.g., API calls, database
  operations) using Repositories/Services to promote testability.

### Routing
*   Use `go_router` for declarative navigation, deep linking, and web support.

    ```dart
    // 1. Add the dependency
    // flutter pub add go_router
    
    // 2. Configure the router
    final GoRouter _router = GoRouter(
      routes: <RouteBase>[
        GoRoute(
          path: '/',
          builder: (context, state) => const HomeScreen(),
          routes: <RouteBase>[
            GoRoute(
              path: 'details/:id', // Route with a path parameter
              builder: (context, state) {
                final String id = state.pathParameters['id']!;
                return DetailScreen(id: id);
              },
            ),
          ],
        ),
      ],
    );
    
    // 3. Use it in your MaterialApp
    MaterialApp.router(
      routerConfig: _router,
    );
    ```

*   Use the built-in `Navigator` for short-lived screens that do not need to be
    deep-linkable, such as dialogs or temporary views.

    ```dart
    // Push a new screen onto the stack
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const DetailsScreen()),
    );
    
    // Pop the current screen to go back
    Navigator.pop(context);
    ```

* **Authentication Redirects:** Configure `go_router`'s `redirect` property to
  handle authentication flows, ensuring users are redirected to the login screen
  when unauthorized, and back to their intended destination after successful
  login.

* **Navigator:** Use the built-in `Navigator` for short-lived screens that do
  not need to be deep-linkable, such as dialogs or temporary views.

  ```dart
  // Push a new screen onto the stack
  Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => const DetailsScreen()),
  );

  // Pop the current screen to go back
  Navigator.pop(context);
  ```
### Data Handling & Serialization
* **JSON Serialization:** Use `json_serializable` and `json_annotation` for
  parsing and encoding JSON data.
* **Field Renaming:** When encoding data, use `fieldRename: FieldRename.snake`
  to convert Dart's camelCase fields to snake_case JSON keys.

  ```dart
  // In your model file
  import 'package:json_annotation/json_annotation.dart';

  part 'user.g.dart';

  @JsonSerializable(fieldRename: FieldRename.snake)
  class User {
    final String firstName;
    final String lastName;

    User({required this.firstName, required this.lastName});

    factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
    Map<String, dynamic> toJson() => _$UserToJson(this);
  }
  ```


### Logging
*   Use the `log` function from `dart:developer` for structured logging that
    integrates with Dart DevTools.

    ```dart
    import 'dart:developer' as developer;
    
    // For simple messages
    developer.log('User logged in successfully.');
    
    // For structured error logging
    try {
      // ... code that might fail
    } catch (e, s) {
      developer.log(
        'Failed to fetch data',
        name: 'myapp.network',
        level: 1000, // SEVERE
        error: e,
        stackTrace: s,
      );
    }
    ```

Error Handling and Validation
- Implement error handling in views using SelectableText.rich instead of SnackBars.
- Display errors in SelectableText.rich with red color for visibility.
- Handle empty states within the displaying screen.
- Use AsyncValue for proper error handling and loading states.

Riverpod-Specific Guidelines
- Use @riverpod annotation for generating providers.
- Prefer AsyncNotifierProvider and NotifierProvider over legacy providers.
- Avoid legacy providers like `StateNotifierProvider`, and `ChangeNotifierProvider` in new code. `StateProvider` can be used for very simple, local state.
- Use ref.invalidate() for manually triggering provider updates.
- Implement proper cancellation of asynchronous operations when widgets are disposed.

Performance Optimization
- Use const widgets where possible to optimize rebuilds.
- Implement list view optimizations (e.g., ListView.builder).
- Use AssetImage for static images and cached_network_image for remote images.
- Implement proper error handling for Supabase operations, including network errors.

Key Conventions
1. Use GoRouter or auto_route for navigation and deep linking.
2. Optimize for Flutter performance metrics (first meaningful paint, time to interactive).
3. Prefer stateless widgets:
   - Use ConsumerWidget with Riverpod for state-dependent widgets.
   - Use HookConsumerWidget when combining Riverpod and Flutter Hooks.

## Visual Design & Theming
* **UI Design:** Build beautiful and intuitive user interfaces that follow
  modern design guidelines.
* **Responsiveness:** Ensure the app is mobile responsive and adapts to
  different screen sizes, working perfectly on mobile and web.
* **Navigation:** If there are multiple pages for the user to interact with,
  provide an intuitive and easy navigation bar or controls.
* **Typography:** Stress and emphasize font sizes to ease understanding, e.g.,
  hero text, section headlines, list headlines, keywords in paragraphs.
* **Background:** Apply subtle noise texture to the main background to add a
  premium, tactile feel.
* **Shadows:** Multi-layered drop shadows create a strong sense of depth; cards
  have a soft, deep shadow to look "lifted."
* **Icons:** Incorporate icons to enhance the user’s understanding and the
  logical navigation of the app.
* **Interactive Elements:** Buttons, checkboxes, sliders, lists, charts, graphs,
  and other interactive elements have a shadow with elegant use of color to
  create a "glow" effect.

### Theming
* **Centralized Theme:** Define a centralized `ThemeData` object to ensure a
  consistent application-wide style.
* **Light and Dark Themes:** Implement support for both light and dark themes,
  ideal for a user-facing theme toggle (`ThemeMode.light`, `ThemeMode.dark`,
  `ThemeMode.system`).
* **Color Scheme Generation:** Generate harmonious color palettes from a single
  color using `ColorScheme.fromSeed`.

  ```dart
  final ThemeData lightTheme = ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.light,
    ),
    // ... other theme properties
  );
  ```
* **Color Palette:** Include a wide range of color concentrations and hues in
  the palette to create a vibrant and energetic look and feel.
* **Component Themes:** Use specific theme properties (e.g., `appBarTheme`,
  `elevatedButtonTheme`) to customize the appearance of individual Material
  components.
* **Custom Fonts:** For custom fonts, you can use the `google_fonts` package or define them manually as you have in `pubspec.yaml`. Define a
  `TextTheme` to apply fonts consistently.

  ```dart
  // 1. Add the dependency
  // flutter pub add google_fonts

  // 2. Define a TextTheme with a custom font
  final TextTheme appTextTheme = TextTheme(
    displayLarge: GoogleFonts.oswald(fontSize: 57, fontWeight: FontWeight.bold),
    titleLarge: GoogleFonts.roboto(fontSize: 22, fontWeight: FontWeight.w500),
    bodyMedium: GoogleFonts.openSans(fontSize: 14),
  );
  ```

### Assets and Images
* **Image Guidelines:** If images are needed, make them relevant and meaningful,
  with appropriate size, layout, and licensing (e.g., freely available). Provide
  placeholder images if real ones are not available.
* **Asset Declaration:** Declare all asset paths in your `pubspec.yaml` file.

    ```yaml
    flutter:
      uses-material-design: true
      assets:
        - assets/images/
    ```

* **Local Images:** Use `Image.asset` for local images from your asset
  bundle.

    ```dart
    Image.asset('assets/images/placeholder.png')
    ```
* **Network images:** Use NetworkImage for images loaded from the network.
* **Cached images:** For cached images, use NetworkImage a package like
  `cached_network_image`.
* **Custom Icons:** Use `ImageIcon` to display an icon from an `ImageProvider`,
  useful for custom icons not in the `Icons` class.
* **Network Images:** Use `Image.network` to display images from a URL, and
  always include `loadingBuilder` and `errorBuilder` for a better user
  experience.

    ```dart
    Image.network(
      'https://picsum.photos/200/300',
      loadingBuilder: (context, child, progress) {
        if (progress == null) return child;
        return const Center(child: CircularProgressIndicator());
      },
      errorBuilder: (context, error, stackTrace) {
        return const Icon(Icons.error);
      },
    )
    ```
## UI Theming and Styling Code

* **Responsiveness:** Use `LayoutBuilder` or `MediaQuery` to create responsive
  UIs.
* **Text:** Use `Theme.of(context).textTheme` for text styles.
* **Text Fields:** Configure `textCapitalization`, `keyboardType`, and
* **Responsiveness:** Use `LayoutBuilder` or `MediaQuery` to create responsive
  UIs.
* **Text:** Use `Theme.of(context).textTheme` for text styles.
  remote images.

```dart
// When using network images, always provide an errorBuilder.
Image.network(
  'https://example.com/image.png',
  errorBuilder: (context, error, stackTrace) {
    return const Icon(Icons.error); // Show an error icon
  },
);
```

## Material Theming Best Practices

### Embrace `ThemeData` and Material 3

* **Use `ColorScheme.fromSeed()`:** Use this to generate a complete, harmonious
  color palette for both light and dark modes from a single seed color.
* **Define Light and Dark Themes:** Provide both `theme` and `darkTheme` to your
  `MaterialApp` to support system brightness settings seamlessly.
* **Centralize Component Styles:** Customize specific component themes (e.g.,
  `elevatedButtonTheme`, `cardTheme`, `appBarTheme`) within `ThemeData` to
  ensure consistency.
* **Dark/Light Mode and Theme Toggle:** Implement support for both light and
  dark themes using `theme` and `darkTheme` properties of `MaterialApp`. The
  `themeMode` property can be dynamically controlled (e.g., via a
  `ChangeNotifierProvider`) to allow for toggling between `ThemeMode.light`,
  `ThemeMode.dark`, or `ThemeMode.system`.

```dart
// main.dart
MaterialApp(
  theme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.light,
    ),
    textTheme: const TextTheme(
      displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
      bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
    ),
  ),
  darkTheme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.dark,
    ),
  ),
  home: const MyHomePage(),
);
```

### Implement Design Tokens with `ThemeExtension`

For custom styles that aren't part of the standard `ThemeData`, use
`ThemeExtension` to define reusable design tokens.

* **Create a Custom Theme Extension:** Define a class that extends
  `ThemeExtension<T>` and include your custom properties.
* **Implement `copyWith` and `lerp`:** These methods are required for the
  extension to work correctly with theme transitions.
* **Register in `ThemeData`:** Add your custom extension to the `extensions`
  list in your `ThemeData`.
* **Access Tokens in Widgets:** Use `Theme.of(context).extension<MyColors>()!`
  to access your custom tokens.

```dart
// 1. Define the extension
@immutable
class MyColors extends ThemeExtension<MyColors> {
  const MyColors({required this.success, required this.danger});

  final Color? success;
  final Color? danger;

  @override
  ThemeExtension<MyColors> copyWith({Color? success, Color? danger}) {
    return MyColors(success: success ?? this.success, danger: danger ?? this.danger);
  }

  @override
  ThemeExtension<MyColors> lerp(ThemeExtension<MyColors>? other, double t) {
    if (other is! MyColors) return this;
    return MyColors(
      success: Color.lerp(success, other.success, t),
      danger: Color.lerp(danger, other.danger, t),
    );
  }
}

// 2. Register it in ThemeData
theme: ThemeData(
  extensions: const <ThemeExtension<dynamic>>[
    MyColors(success: Colors.green, danger: Colors.red),
  ],
),

// 3. Use it in a widget
Container(
  color: Theme.of(context).extension<MyColors>()!.success,
)
```

### Styling with `WidgetStateProperty`

* **`WidgetStateProperty.resolveWith`:** Provide a function that receives a
  `Set<WidgetState>` and returns the appropriate value for the current state.
* **`WidgetStateProperty.all`:** A shorthand for when the value is the same for
  all states.

```dart
// Example: Creating a button style that changes color when pressed.
final ButtonStyle myButtonStyle = ButtonStyle(
  backgroundColor: WidgetStateProperty.resolveWith<Color>(
    (Set<WidgetState> states) {
      if (states.contains(WidgetState.pressed)) {
        return Colors.green; // Color when pressed
      }
      return Colors.red; // Default color
    },
  ),
);
```

## Layout Best Practices

### Building Flexible and Overflow-Safe Layouts

#### For Rows and Columns

* **`Expanded`:** Use to make a child widget fill the remaining available space
  along the main axis.
* **`Flexible`:** Use when you want a widget to shrink to fit, but not
  necessarily grow. Don't combine `Flexible` and `Expanded` in the same `Row` or
  `Column`.
* **`Wrap`:** Use when you have a series of widgets that would overflow a `Row`
  or `Column`, and you want them to move to the next line.

#### For General Content

* **`SingleChildScrollView`:** Use when your content is intrinsically larger
  than the viewport, but is a fixed size.
* **`ListView` / `GridView`:** For long lists or grids of content, always use a
  builder constructor (`.builder`).
* **`FittedBox`:** Use to scale or fit a single child widget within its parent.
* **`LayoutBuilder`:** Use for complex, responsive layouts to make decisions
  based on the available space.

### Layering Widgets with Stack

* **`Positioned`:** Use to precisely place a child within a `Stack` by anchoring it to the edges.
* **`Align`:** Use to position a child within a `Stack` using alignments like `Alignment.center`.

### Advanced Layout with Overlays

* **`OverlayPortal`:** Use this widget to show UI elements (like custom
  dropdowns or tooltips) "on top" of everything else. It manages the
  `OverlayEntry` for you.

  ```dart
  class MyDropdown extends StatefulWidget {
    const MyDropdown({super.key});

    @override
    State<MyDropdown> createState() => _MyDropdownState();
  }

  class _MyDropdownState extends State<MyDropdown> {
    final _controller = OverlayPortalController();

    @override
    Widget build(BuildContext context) {
      return OverlayPortal(
        controller: _controller,
        overlayChildBuilder: (BuildContext context) {
          return const Positioned(
            top: 50,
            left: 10,
            child: Card(
              child: Padding(
                padding: EdgeInsets.all(8.0),
                child: Text('I am an overlay!'),
              ),
            ),
          );
        },
        child: ElevatedButton(
          onPressed: _controller.toggle,
          child: const Text('Toggle Overlay'),
        ),
      );
    }
  }
  ```

## Color Scheme Best Practices

### Contrast Ratios

* **WCAG Guidelines:** Aim to meet the Web Content Accessibility Guidelines
  (WCAG) 2.1 standards.
* **Minimum Contrast:**
    * **Normal Text:** A contrast ratio of at least **4.5:1**.
    * **Large Text:** (18pt or 14pt bold) A contrast ratio of at least **3:1**.

### Palette Selection

* **Primary, Secondary, and Accent:** Define a clear color hierarchy.
* **The 60-30-10 Rule:** A classic design rule for creating a balanced color scheme.
    * **60%** Primary/Neutral Color (Dominant)
    * **30%** Secondary Color
    * **10%** Accent Color

### Complementary Colors

* **Use with Caution:** They can be visually jarring if overused.
* **Best Use Cases:** They are excellent for accent colors to make specific
  elements pop, but generally poor for text and background pairings as they can
  cause eye strain.

### Example Palette

* **Primary:** #0D47A1 (Dark Blue)
* **Secondary:** #1976D2 (Medium Blue)
* **Accent:** #FFC107 (Amber)
* **Neutral/Text:** #212121 (Almost Black)
* **Background:** #FEFEFE (Almost White)

## Font Best Practices

### Font Selection

* **Limit Font Families:** Stick to one or two font families for the entire
  application.
* **Prioritize Legibility:** Choose fonts that are easy to read on screens of
  all sizes. Sans-serif fonts are generally preferred for UI body text.
* **System Fonts:** Consider using platform-native system fonts.
* **Google Fonts:** For a wide selection of open-source fonts, use the
  `google_fonts` package.

### Hierarchy and Scale

* **Establish a Scale:** Define a set of font sizes for different text elements
  (e.g., headlines, titles, body text, captions).
* **Use Font Weight:** Differentiate text effectively using font weights.
* **Color and Opacity:** Use color and opacity to de-emphasize less important
  text.

### Readability

* **Line Height (Leading):** Set an appropriate line height, typically **1.4x to
  1.6x** the font size.
* **Line Length:** For body text, aim for a line length of **45-75 characters**.
* **Avoid All Caps:** Do not use all caps for long-form text.

### Example Typographic Scale

```dart
// In your ThemeData
textTheme: const TextTheme(
  displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
  titleLarge: TextStyle(fontSize: 22.0, fontWeight: FontWeight.bold),
  bodyLarge: TextStyle(fontSize: 16.0, height: 1.5),
  bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
  labelSmall: TextStyle(fontSize: 11.0, color: Colors.grey),
),
```
Miscellaneous
- Use log instead of print for debugging.
- Use Flutter Hooks / Riverpod Hooks where appropriate.
- Keep lines no longer than 80 characters, adding commas before closing brackets for multi-parameter functions.
- Use @JsonValue(int) for enums that go to the database.

## Code Generation
* **Build Runner:** If the project uses code generation, ensure that
  `build_runner` is listed as a dev dependency in `pubspec.yaml`.
* **Code Generation Tasks:** Use `build_runner` for all code generation tasks,
  such as for `json_serializable`.
* **Running Build Runner:** After modifying files that require code generation,
  run the build command:

  ```shell
  dart run build_runner build --delete-conflicting-outputs
  ```

## Testing
* **Running Tests:** To run tests, use the `run_tests` tool if it is available,
  otherwise use `flutter test`.
* **Unit Tests:** Use `package:test` for unit tests.
* **Widget Tests:** Use `package:flutter_test` for widget tests.
* **Integration Tests:** Use `package:integration_test` for integration tests.
* **Assertions:** Prefer using `package:checks` for more expressive and readable
  assertions over the default `matchers`.

### Testing Best practices
* **Convention:** Follow the Arrange-Act-Assert (or Given-When-Then) pattern.
* **Unit Tests:** Write unit tests for domain logic, data layer, and state
  management.
* **Widget Tests:** Write widget tests for UI components.
* **Integration Tests:** For broader application validation, use integration
  tests to verify end-to-end user flows.
* **integration_test package:** Use the `integration_test` package from the
  Flutter SDK for integration tests. Add it as a `dev_dependency` in
  `pubspec.yaml` by specifying `sdk: flutter`.
* **Mocks:** Prefer fakes or stubs over mocks. If mocks are absolutely
  necessary, use `mockito` or `mocktail` to create mocks for dependencies. Your project uses `mockito`. While
  code generation is common for state management (e.g., with `freezed`), try to
  avoid it for mocks.
* **Coverage:** Aim for high test coverage.

## Documentation

* **`dartdoc`:** Write `dartdoc`-style comments for all public APIs.


### Documentation Philosophy

* **Comment wisely:** Use comments to explain why the code is written a certain
  way, not what the code does. The code itself should be self-explanatory.
* **Document for the user:** Write documentation with the reader in mind. If you
  had a question and found the answer, add it to the documentation where you
  first looked. This ensures the documentation answers real-world questions.
* **No useless documentation:** If the documentation only restates the obvious
  from the code's name, it's not helpful. Good documentation provides context
  and explains what isn't immediately apparent.
* **Consistency is key:** Use consistent terminology throughout your
  documentation.

### Commenting Style

* **Use `///` for doc comments:** This allows documentation generation tools to
  pick them up.
* **Start with a single-sentence summary:** The first sentence should be a
  concise, user-centric summary ending with a period.
* **Separate the summary:** Add a blank line after the first sentence to create
  a separate paragraph. This helps tools create better summaries.
* **Avoid redundancy:** Don't repeat information that's obvious from the code's
  context, like the class name or signature.
* **Don't document both getter and setter:** For properties with both, only
  document one. The documentation tool will treat them as a single field.

### Writing Style

* **Be brief:** Write concisely.
* **Avoid jargon and acronyms:** Don't use abbreviations unless they are widely
  understood.
* **Use Markdown sparingly:** Avoid excessive markdown and never use HTML for
  formatting.
* **Use backticks for code:** Enclose code blocks in backtick fences, and
  specify the language.

### What to Document

* **Public APIs are a priority:** Always document public APIs.
* **Consider private APIs:** It's a good idea to document private APIs as well.
* **Library-level comments are helpful:** Consider adding a doc comment at the
  library level to provide a general overview.
* **Include code samples:** Where appropriate, add code samples to illustrate usage.
* **Explain parameters, return values, and exceptions:** Use prose to describe
  what a function expects, what it returns, and what errors it might throw.
* **Place doc comments before annotations:** Documentation should come before
  any metadata annotations.

## Accessibility (A11Y)
Implement accessibility features to empower all users, assuming a wide variety
of users with different physical abilities, mental abilities, age groups,
education levels, and learning styles.

* **Color Contrast:** Ensure text has a contrast ratio of at least **4.5:1**
  against its background.
* **Dynamic Text Scaling:** Test your UI to ensure it remains usable when users
  increase the system font size.
* **Semantic Labels:** Use the `Semantics` widget to provide clear, descriptive
  labels for UI elements.
* **Screen Reader Testing:** Regularly test your app with TalkBack (Android) and
  VoiceOver (iOS).
Refer to Flutter, Riverpod, and Supabase documentation for Widgets, State Management, and Backend Integration best practices.

# Riverpod Architecture Guide

## Overview

This document defines architectural best practices and conventions for Flutter projects using **Riverpod** for state management. The goal is to ensure code quality, maintainability, and scalability across teams.

### Why Riverpod?

- **Compile-time safety**: Catches provider access errors at compile time
- **No BuildContext required**: Access providers from anywhere in the app.
- **Excellent testing**: Easy to override providers for testing.
- **Auto-disposal**: Automatic memory management with `.autoDispose`.
- **Developer experience**: Great tooling and debugging support.
- **Performance**: Fine-grained reactivity and selective rebuilds.

---

## Clean Architecture Layers

Even if your folder names do not explicitly use `domain`, `data`, or `presentation`, these layers exist logically in your codebase. Organizing by feature or by layer is both acceptable, as long as you respect the **Dependency Rule**.

### Data Layer ("How")

This layer answers: **How is data fetched or stored?** It contains all implementation details and external dependencies.

**Components:**
- **Repository Implementations:** Concrete classes implementing domain repository interfaces as providers (e.g., `authRepositoryProvider`)
- **Data Sources:** Provider-based classes responsible for interacting with a single data source (e.g., `userRemoteDataSourceProvider`, `userLocalDataSourceProvider`)
- **DTOs (Data Transfer Objects):** Models for parsing and serializing data from APIs (e.g., `UserDto`)
- **Dependencies:** Uses packages like Dio, Hive, etc. No other layer depends on Data (except for DI setup)

### Domain Layer ("What")

This layer answers: **What can the app do?** It is the core of your business logic and is independent of frameworks and tools.

**Components:**
- **Entities:** Pure Dart objects representing core business concepts (e.g., `User`)
- **Repository Interfaces:** Abstract classes defining contracts for data access (e.g., `abstract class IAuthRepository`)
- **Use Cases:** Provider-based classes encapsulating specific business actions (e.g., `loginUseCaseProvider`). In small/medium apps, UI providers may call repository methods directly instead of separate use cases
- **Dependencies:** No dependencies on other layers or frameworks

### Presentation Layer ("Show")

This layer answers: **What is displayed and how does the user interact?**

**Components:**
- **UI (Views):** Widgets and pages using `ConsumerWidget` or `HookConsumerWidget`
- **State Management:** StateNotifierProvider, Provider, and their States. Providers interact with the Domain layer and expose state to the UI

### Example Folder Structure (Feature-Based)

```text
lib/
├── features/
│   ├── auth/
│   │   ├── data/
│   │   │   ├── datasources/
│   │   │   ├── models/
│   │   │   ├── providers/
│   │   │   └── repositories/
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── providers/
│   │   │   ├── repositories/
│   │   │   └── usecases/
│   │   └── presentation/
│   │       ├── notifiers/
│   │       ├── providers/
│   │       ├── pages/
│   │       └── widgets/
│   └── home/
│       ├── data/
│       ├── domain/
│       └── presentation/
└── shared/
    ├── data/
    ├── domain/
    └── presentation/
```

### Dependency Rule

The most important rule is to respect the **Dependency Rule**:

**Presentation → Domain ← Data**

This ensures a clean, maintainable architecture regardless of folder naming:
- **Presentation layer** can depend on Domain layer
- **Data layer** can depend on Domain layer  
- **Domain layer** cannot depend on any other layer
- **Data and Presentation** layers cannot depend on each other directly

---
# Riverpod Conventions & Organization

## Naming Conventions

### Provider Names
- **Provider variables**: camelCase, suffix with `Provider` (e.g., `authRepositoryProvider`, `userProfileProvider`)
- **StateNotifierProvider**: camelCase, suffix with `Provider` (e.g., `loginNotifierProvider`, `userListNotifierProvider`)
- **FutureProvider**: camelCase, describe what it provides (e.g., `currentUserProvider`, `userListProvider`)
- **StreamProvider**: camelCase, suffix with `StreamProvider` (e.g., `authStateStreamProvider`, `messagesStreamProvider`)

### Class Names
- **StateNotifier classes**: PascalCase, suffix with `Notifier` (e.g., `LoginNotifier`, `UserProfileNotifier`)
- **State classes**: PascalCase, suffix with `State` (e.g., `LoginState`, `UserProfileState`)
- **Repository classes**: PascalCase, suffix with `Repository` (e.g., `IAuthRepository`, `UserRepository`)
- **Use case classes**: PascalCase, suffix with `UseCase` (e.g., `LoginUseCase`, `GetUserUseCase`)

### Files
- **Provider files**: snake_case, suffix with `_providers` (e.g., `auth_providers.dart`, `user_providers.dart`)
- **Notifier files**: snake_case, suffix with `_notifier` (e.g., `login_notifier.dart`, `user_profile_notifier.dart`)
- **State files**: snake_case, suffix with `_state` (e.g., `login_state.dart`, `user_profile_state.dart`)
- **Test files**: Add `_test` suffix (e.g., `login_notifier_test.dart`)
- **Mock files**: Add `_mock` suffix (e.g., `auth_repository_mock.dart`)

### Folders
- **Features**: snake_case (e.g., `user_profile`, `shopping_cart`)
- **Layers**: lowercase (e.g., `data`, `domain`, `presentation`)
- **Components**: lowercase plural (e.g., `providers`, `notifiers`, `widgets`, `pages`)

### Examples

```dart
// ✅ Good naming
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

final authRepositoryProvider = Provider.autoDispose<IAuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});

final currentUserProvider = FutureProvider.autoDispose<User>((ref) {
  return ref.read(authRepositoryProvider).getCurrentUser();
});

// ❌ Bad naming
final login = StateNotifierProvider<LoginNotifier, LoginData>((ref) {
  return LoginNotifier(ref.read(authRepo));
});

final auth_repository = Provider<AuthRepo>((ref) {
  return AuthRepoImpl(ref.read(restClient));
});
```

---

## File & Directory Organization

### Feature-First

**Feature-First:**
```
lib/
├── features/
│   ├── auth/
│   │   ├── data/
│   │   ├── domain/
│   │   └── presentation/
│   └── dashboard/
│       ├── data/
│       ├── domain/
│       └── presentation/
└── shared/
    ├── data/
    ├── domain/
    └── presentation/
```

### File Organization Best Practices

1. **Separate provider files**: Group related providers in dedicated files
2. **Logical grouping**: Group related files in folders
3. **Test placement**: Mirror production structure in `test/` folder
4. **Barrel exports**: Use `index.dart` files for easier imports

```dart
// lib/features/auth/auth.dart (barrel file)
export 'data/providers/auth_data_providers.dart';
export 'domain/providers/auth_domain_providers.dart';
export 'presentation/providers/auth_ui_providers.dart';
export 'presentation/notifiers/login_notifier.dart';
export 'presentation/notifiers/login_state.dart';
export 'presentation/pages/login_page.dart';
```

### Provider File Organization

```dart
// lib/features/auth/presentation/providers/auth_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// UI State Providers
final obscurePasswordProvider = StateProvider.autoDispose<bool>((ref) => true);

final loginFormProvider = StateProvider.autoDispose<LoginFormData>((ref) {
  return LoginFormData.empty();
});

// Notifier Providers
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(
    authRepository: ref.read(authRepositoryProvider),
    analytics: ref.read(analyticsProvider),
  );
});

// Computed Providers
final isLoginFormValidProvider = Provider.autoDispose<bool>((ref) {
  final formData = ref.watch(loginFormProvider);
  return formData.email.isNotEmpty && formData.password.length >= 6;
});

// Future Providers
final currentUserProvider = FutureProvider.autoDispose<User?>((ref) {
  return ref.read(authRepositoryProvider).getCurrentUser();
});
```

---

## Provider Types & Usage

### Provider Type Guidelines

**Use `Provider` for:**
- Immutable services (repositories, use cases)
- Configuration objects
- Computed values that don't change often

```dart
final configProvider = Provider<AppConfig>((ref) {
  return AppConfig();
});

final authRepositoryProvider = Provider.autoDispose<IAuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});
```

**Use `StateProvider` for:**
- Simple, local, synchronous, mutable state.
- UI flags and toggles (e.g., `obscurePasswordProvider`).
- Form field values.

```dart
final counterProvider = StateProvider<int>((ref) => 0);

final obscurePasswordProvider = StateProvider.autoDispose<bool>((ref) => true);

final selectedTabProvider = StateProvider<int>((ref) => 0);
```

**Use `(Async)NotifierProvider` for:**
- Complex state management.
- Business logic with multiple state transitions and side effects.
- Asynchronous operations that need to be managed.

```dart
final userListNotifierProvider = StateNotifierProvider.autoDispose<UserListNotifier, UserListState>((ref) {
  return UserListNotifier(ref.read(userRepositoryProvider));
});
```

**Use `FutureProvider` for:**
- Async data that loads once
- API calls without complex state
- Data transformation

```dart
final userListProvider = FutureProvider.autoDispose<List<User>>((ref) {
  return ref.read(userRepositoryProvider).getUsers();
});

final userByIdProvider = FutureProvider.family.autoDispose<User, String>((ref, userId) {
  return ref.read(userRepositoryProvider).getUserById(userId);
});
```

**Use `StreamProvider` for:**
- Continuous data streams
- WebSocket connections
- Real-time updates

```dart
final authStateStreamProvider = StreamProvider<AuthState>((ref) {
  return ref.read(authServiceProvider).authStateStream;
});

final messagesStreamProvider = StreamProvider.family.autoDispose<List<Message>, String>((ref, chatId) {
  return ref.read(messageServiceProvider).getMessagesStream(chatId);
});
```

### AutoDispose Guidelines

**Use `.autoDispose` for:**
- Feature-specific providers that should be destroyed when no longer used.
- UI state that should reset when leaving a screen.
- Providers holding expensive resources that should be released.

```dart
// ✅ Good: Feature-specific state
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

// ✅ Good: UI state
final searchQueryProvider = StateProvider.autoDispose<String>((ref) => '');
```

**Don't use `.autoDispose` for:**
- Global app state that should persist (e.g., user authentication status).
- Shared services that are used across multiple features (e.g., `Dio` instance).
- Configuration providers.

```dart
// ✅ Good: Global services
final authRepositoryProvider = Provider<IAuthRepository>((ref) {
  return AuthRepositoryImpl(ref.read(restClientProvider));
});

// ✅ Good: App configuration
final appConfigProvider = Provider<AppConfig>((ref) {
  return AppConfig();
});
```

---

## Dependency Injection

### Manual Dependency Injection with Riverpod

Your project uses `injectable` for dependency injection, but Riverpod itself is a powerful DI framework. The following shows how to manually wire dependencies using providers, which is the common pattern in many Riverpod apps.

```dart
// lib/core/providers/app_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Infrastructure
final restClientProvider = Provider<RestClient>((ref) {
  return RestClient();
});

final localStorageProvider = Provider<LocalStorage>((ref) {
  return HiveLocalStorage();
});

// Repositories
final authRepositoryProvider = Provider.autoDispose<IAuthRepository>((ref) {
  return AuthRepositoryImpl(
    restClient: ref.read(restClientProvider),
    localStorage: ref.read(localStorageProvider),
  );
});

final userRepositoryProvider = Provider.autoDispose<UserRepository>((ref) {
  return UserRepositoryImpl(
    restClient: ref.read(restClientProvider),
    localStorage: ref.read(localStorageProvider),
  );
});

// Use Cases
final loginUseCaseProvider = Provider.autoDispose<LoginUseCase>((ref) {
  return LoginUseCase(ref.read(authRepositoryProvider));
});
```

### Provider Overrides

For testing or different implementations:

```dart
// In main.dart
final overrides = [
  restClientProvider.overrideWith((ref) => MockRestClient()),
  localStorageProvider.overrideWith((ref) => MockLocalStorage()),
];

runApp(ProviderScope(
  overrides: overrides,
  child: MyApp(),
));

// In tests
testWidgets('should work correctly', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        authRepositoryProvider.overrideWith((ref) => MockIAuthRepository()),
        userRepositoryProvider.overrideWith((ref) => MockUserRepository()),
      ],
      child: MyApp(),
    ),
  );
});
```

### Module-Based Organization

For larger projects, organize providers by modules:

```dart
// lib/features/auth/providers/auth_module.dart
class AuthModule {
  static final providers = [
    authRepositoryProvider,
    loginUseCaseProvider,
    loginNotifierProvider,
  ];
  
  static final overrides = <Override>[];
}

// lib/features/user/providers/user_module.dart
class UserModule {
  static final providers = [
    userRepositoryProvider,
    userListNotifierProvider,
    userProfileNotifierProvider,
  ];
}

// In main.dart
final allOverrides = [
  ...AuthModule.overrides,
  ...UserModule.overrides,
];

runApp(ProviderScope(
  overrides: allOverrides,
  child: MyApp(),
));
```

### Cross-Module Dependencies

- Shared providers are defined in `shared/providers/`
- Feature modules import shared providers as needed
- Use provider overrides for testing cross-module interactions

```dart
// shared/providers/shared_providers.dart
final restClientProvider = Provider<RestClient>((ref) {
  return RestClient();
});

final analyticsProvider = Provider<Analytics>((ref) {
  return FirebaseAnalytics();
});

// feature/auth/providers/auth_providers.dart
import 'package:shared/providers/shared_providers.dart';

final authRepositoryProvider = Provider.autoDispose<IAuthRepository>((ref) {
  return AuthRepositoryImpl(
    restClient: ref.read(restClientProvider), // Shared dependency
    analytics: ref.read(analyticsProvider), // Shared dependency
  );
});
```

### Provider Lifecycle Management

- Use `keepAlive()` to prevent auto-disposal when needed
- Use `ref.invalidate()` to force provider refresh
- Always clean up resources in StateNotifier

```dart
// Prevent auto-disposal conditionally
final userCacheProvider = FutureProvider.autoDispose<List<User>>((ref) {
  final users = await fetchUsers();
  
  // Keep alive if users are loaded
  if (users.isNotEmpty) {
    ref.keepAlive();
  }
  
  return users;
});

// Force refresh
ref.invalidate(userListProvider);

// Clean up in StateNotifier
class UserListNotifier extends StateNotifier<UserListState> {
  StreamSubscription? _subscription;
  
  UserListNotifier(this._repository) : super(UserListState.initial()) {
    _subscription = _repository.userStream.listen(_updateUsers);
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}
``` 
# Riverpod Development Practices

## Networking & Error Handling

### Repository with Error Handling

```dart
final apiServiceProvider = Provider<ApiService>((ref) {
  return ApiService();
});

final userRepositoryProvider = Provider.autoDispose<UserRepository>((ref) {
  return UserRepositoryImpl(ref.read(apiServiceProvider));
});

class UserRepositoryImpl implements UserRepository {
  final ApiService _apiService;
  UserRepositoryImpl(this._apiService);

  @override
  Future<Result<User>> getUser(String id) async {
    try {
      final response = await _apiService.dio.get('/users/$id');
      final user = User.fromJson(response.data);
      return Result.success(data: user);
    } on DioException catch (e) {
      return Result.failure(error: _handleDioError(e));
    } catch (e) {
      return Result.failure(error: AppException('Unexpected error: $e'));
    }
  }
}
```

### StateNotifier with Error Handling

```dart
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  return UserNotifier(ref.read(userRepositoryProvider));
});

class UserNotifier extends StateNotifier<UserState> {
  final UserRepository _repository;
  
  UserNotifier(this._repository) : super(UserState.initial());

  Future<void> loadUser(String id) async {
    state = state.copyWith(isLoading: true, error: null);
    
    final result = await _repository.getUser(id);
    
    result.when(
      success: (user) => state = state.copyWith(
        isLoading: false,
        user: user,
      ),
      failure: (error) => state = state.copyWith(
        isLoading: false,
        error: error.message,
      ),
    );
  }
}
```

---

## Testing

### Unit Testing Providers

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

void main() {
  group('UserNotifier', () {
    late ProviderContainer container;
    late MockUserRepository mockRepository;

    setUp(() {
      mockRepository = MockUserRepository();
      container = ProviderContainer(
        overrides: [
          userRepositoryProvider.overrideWith((ref) => mockRepository),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('should load user successfully', () async {
      // Given
      const userId = '123';
      final mockUser = User(id: userId, name: 'Test User');
      when(() => mockRepository.getUser(userId))
          .thenAnswer((_) async => Result.success(data: mockUser));

      // When
      final notifier = container.read(userNotifierProvider.notifier);
      await notifier.loadUser(userId);

      // Then
      final state = container.read(userNotifierProvider);
      expect(state.user, equals(mockUser));
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
    });
  });
}
```

### Widget Testing with Riverpod

```dart
testWidgets('should display user data correctly', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        userRepositoryProvider.overrideWith((ref) => MockUserRepository()),
      ],
      child: MaterialApp(home: UserPage()),
    ),
  );

  // Test implementation
  expect(find.text('Test User'), findsOneWidget);
});
```

---

## Performance Optimization

### Selective Watching

```dart
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ❌ Bad: Watches entire state
    final userState = ref.watch(userNotifierProvider);
    
    // ✅ Good: Watches only specific field
    final isLoading = ref.watch(userNotifierProvider.select((state) => state.isLoading));
    final userName = ref.watch(userNotifierProvider.select((state) => state.user?.name));
    
    return Column(
      children: [
        if (isLoading) CircularProgressIndicator(),
        if (userName != null) Text(userName),
      ],
    );
  }
}
```

### Provider Granularity

```dart
// ✅ Good: Focused providers
final userNameProvider = Provider.autoDispose<String?>((ref) {
  return ref.watch(userNotifierProvider.select((state) => state.user?.name));
});

final userLoadingProvider = Provider.autoDispose<bool>((ref) {
  return ref.watch(userNotifierProvider.select((state) => state.isLoading));
});
```

---

## Best Practices

### State Structure with Freezed

```dart
@freezed
class UserState with _$UserState {
  const factory UserState({
    @Default(false) bool isLoading,
    @Default(null) User? user,
    @Default(null) String? error,
  }) = _UserState;
  
  factory UserState.initial() => const UserState();
}
```

### Error Handling Pattern

```dart
class UserNotifier extends StateNotifier<UserState> {
  UserNotifier(this._repository) : super(UserState.initial());

  Future<void> loadUser(String id) async {
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      final user = await _repository.getUser(id);
      state = state.copyWith(isLoading: false, user: user);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }
}
```

### Provider Dependencies

```dart
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  final repository = ref.watch(userRepositoryProvider);
  final analytics = ref.read(analyticsProvider);
  
  return UserNotifier(repository, analytics);
});
```

### Cleanup Resources

```dart
class UserNotifier extends StateNotifier<UserState> {
  StreamSubscription? _subscription;
  
  UserNotifier(this._repository) : super(UserState.initial()) {
    _subscription = _repository.userStream.listen(_updateUser);
  }
  
  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
} 

# Riverpod State Management Guide

## State Management with StateNotifier & Freezed


```dart
@freezed
class LoginState with _$LoginState {
  const factory LoginState({
    @Default(LoginStatus.initial) LoginStatus status,
    @Default(null) String? error,
    @Default(null) User? user,
    @Default(false) bool isLoading,
    @Default(true) bool obscurePassword,
  }) = _LoginState;

  factory LoginState.initial() => const LoginState();
  
  const LoginState._();
  bool get isAuthenticated => user != null;
  bool get hasError => error != null;
}
```

### StateNotifier Implementation

```dart
final loginNotifierProvider = StateNotifierProvider.autoDispose<LoginNotifier, LoginState>((ref) {
  return LoginNotifier(ref.read(authRepositoryProvider));
});

class LoginNotifier extends StateNotifier<LoginState> {
  final IAuthRepository _authRepository;

  LoginNotifier(this._authRepository) : super(LoginState.initial());

  Future<void> login(String email, String password) async {
    if (email.isEmpty || password.isEmpty) {
      state = state.copyWith(
        status: LoginStatus.failure,
        error: 'Email and password cannot be empty',
      );
      return;
    }

    state = state.copyWith(status: LoginStatus.loading, isLoading: true);

    try {
      final user = await _authRepository.login(email, password);
      state = state.copyWith(
        status: LoginStatus.success,
        user: user,
        error: null,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        status: LoginStatus.failure,
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void togglePasswordVisibility() {
    state = state.copyWith(obscurePassword: !state.obscurePassword);
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}
```

---

## Hook Usage Guidelines

### Hook Organization in build() Method

```dart
class LoginPage extends HookConsumerWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Form hooks
    final emailController = useTextEditingController();
    final passwordController = useTextEditingController();
    final formKey = useMemoized(() => GlobalKey<FormState>());
    
    // 2. State hooks
    final focusNode = useFocusNode();
    
    // 3. Effect hooks
    useEffect(() {
      // Side effect logic
      return null;
    }, []);
    
    // 4. Riverpod providers
    final loginState = ref.watch(loginNotifierProvider);
    final loginNotifier = ref.read(loginNotifierProvider.notifier);
    
    // 5. Computed values
    final isFormValid = useMemoized(() {
      return emailController.text.isNotEmpty && 
             passwordController.text.length >= 6;
    }, [emailController.text, passwordController.text]);
    
    // 6. Listen for side effects
    ref.listen<LoginState>(loginNotifierProvider, (previous, next) {
      if (next.status == LoginStatus.success) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => HomePage()),
        );
      }
    });
    
    return Scaffold(
      body: Form(
        key: formKey,
        child: Column(
          children: [
            TextFormField(
              controller: emailController,
              focusNode: focusNode,
            ),
            TextFormField(
              controller: passwordController,
              obscureText: loginState.obscurePassword,
            ),
            ElevatedButton(
              onPressed: isFormValid ? () {
                loginNotifier.login(
                  emailController.text,
                  passwordController.text,
                );
              } : null,
              child: Text('Login'),
            ),
          ],
        ),
      ),
    );
  }
}
```

### Avoid Unnecessary Function Parameters

```dart
// ✅ Good: Direct closure usage
class MyWidget extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController();
    final theme = Theme.of(context);
    
    Widget _buildHeader() {
      return Container(
        color: theme.primaryColor,
        child: TextField(controller: controller),
      );
    }
    
    return Scaffold(body: _buildHeader());
  }
}
```

---

## State Patterns

### Loading States

```dart
@freezed
class AsyncState<T> with _$AsyncState<T> {
  const factory AsyncState.loading() = AsyncLoading<T>;
  const factory AsyncState.data(T value) = AsyncData<T>;
  const factory AsyncState.error(String message) = AsyncError<T>;
}

class UserListNotifier extends StateNotifier<AsyncState<List<User>>> {
  UserListNotifier(this._repository) : super(const AsyncState.loading());

  Future<void> loadUsers() async {
    state = const AsyncState.loading();
    
    try {
      final users = await _repository.getUsers();
      state = AsyncState.data(users);
    } catch (e) {
      state = AsyncState.error(e.toString());
    }
  }
}
```

### Form State Pattern

```dart
@freezed
class FormState<T> with _$FormState<T> {
  const factory FormState({
    @Default(false) bool isSubmitting,
    @Default(null) T? data,
    @Default({}) Map<String, String> errors,
    @Default(null) String? submitError,
  }) = _FormState<T>;
  
  const FormState._();
  bool get hasErrors => errors.isNotEmpty;
  bool get isValid => !hasErrors && data != null;
}
```

---

## Error Handling in State

### Global Error Handling

```dart
final errorNotifierProvider = StateNotifierProvider<ErrorNotifier, ErrorState>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<ErrorState> {
  ErrorNotifier() : super(ErrorState.initial());

  void showError(String message) {
    state = state.copyWith(error: message, hasError: true);
  }

  void clearError() {
    state = state.copyWith(error: null, hasError: false);
  }
}

// Usage in other notifiers
class UserNotifier extends StateNotifier<UserState> {
  final Ref _ref;
  
  UserNotifier(this._ref, this._repository) : super(UserState.initial());

  Future<void> loadUser() async {
    try {
      // ... load user logic
    } catch (e) {
      _ref.read(errorNotifierProvider.notifier).showError(e.toString());
    }
  }
}
```

### Result Pattern

```dart
@freezed
class Result<T> with _$Result<T> {
  const factory Result.success({required T data}) = Success<T>;
  const factory Result.failure({required String error}) = Failure<T>;
}

// Usage
Future<Result<User>> login(String email, String password) async {
  try {
    final user = await _authRepository.login(email, password);
    return Result.success(data: user);
  } catch (e) {
    return Result.failure(error: e.toString());
  }
}
``` 
# Riverpod Tooling & Configuration


## Recommended Packages

```yaml
environment:
   sdk: ^3.8.0  

dependencies:
  freezed: ^3.2.0
  freezed_annotation: ^3.1.0
  equatable: ^2.0.5

  #state management
  flutter_riverpod: ^3.0.0
  riverpod_annotation: ^3.0.0

  #hooks
  flutter_hooks: ^0.21.3+1
  hooks_riverpod: ^3.0.0

dev_dependencies:
  json_serializable: ^6.11.0

  build_runner: ^2.7.1
  freezed: ^3.2.0

  #envied generator
  envied_generator: ^1.2.1
  
  #injectable generator
  injectable_generator: ^2.6.2

  #riverpod generator
  riverpod_generator: ^3.0.0

  #riverpod lint
  riverpod_lint: ^3.0.0


  #test
  mockito: ^5.5.0
```

---

## Configuration Management

### Environment Configuration with Riverpod

```dart
// Abstract configuration
abstract class AppConfig {
  String get apiBaseUrl;
  String get apiKey;
  bool get enableLogging;
}

// Configuration provider
final appConfigProvider = Provider<AppConfig>((ref) {
  const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'dev');
  
  switch (environment) {
    case 'prod':
      return ProdAppConfig();
    case 'staging':
      return StagingAppConfig();
    default:
      return DevAppConfig();
  }
});

// Development configuration
class DevAppConfig implements AppConfig {
  @override
  String get apiBaseUrl => 'https://dev-api.example.com';
  
  @override
  String get apiKey => 'dev_api_key';
  
  @override
  bool get enableLogging => true;
}
```

### Provider-based DI Container

```dart
// Core providers
final dioProvider = Provider<Dio>((ref) {
  final config = ref.read(appConfigProvider);
  return Dio(BaseOptions(
    baseUrl: config.apiBaseUrl,
    headers: {'Authorization': 'Bearer ${config.apiKey}'},
  ));
});

final localStorageProvider = Provider<LocalStorage>((ref) {
  return HiveLocalStorage();
});

// Repository providers
final authRepositoryProvider = Provider.autoDispose<IAuthRepository>((ref) {
  return AuthRepositoryImpl(
    dio: ref.read(dioProvider),
    localStorage: ref.read(localStorageProvider),
  );
});
```

---

## Flutter App Flavors

### Flavor-based Provider Overrides

```dart
// main_dev.dart
void main() {
  runApp(
    ProviderScope(
      overrides: [
        appConfigProvider.overrideWith((ref) => DevAppConfig()),
      ],
      child: MyApp(),
    ),
  );
}

// main_prod.dart
void main() {
  runApp(
    ProviderScope(
      overrides: [
        appConfigProvider.overrideWith((ref) => ProdAppConfig()),
      ],
      child: MyApp(),
    ),
  );
}
```

### Feature Flags with Riverpod

```dart
final featureFlagsProvider = Provider<FeatureFlags>((ref) {
  final config = ref.read(appConfigProvider);
  return FeatureFlags(
    enableNewUI: config.enableNewUI,
    enableAnalytics: config.enableAnalytics,
  );
});

final shouldShowNewUIProvider = Provider<bool>((ref) {
  return ref.read(featureFlagsProvider).enableNewUI;
});

// Usage in widgets
class HomePage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final showNewUI = ref.watch(shouldShowNewUIProvider);
    
    return showNewUI ? NewHomePage() : LegacyHomePage();
  }
}
```

---

## Common Scenarios & Solutions

### Caching with Riverpod

```dart
final userCacheProvider = StateNotifierProvider<UserCacheNotifier, Map<String, User>>((ref) {
  return UserCacheNotifier();
});

final userByIdProvider = FutureProvider.family.autoDispose<User, String>((ref, userId) async {
  final cache = ref.read(userCacheProvider);
  
  // Return cached user if available
  if (cache.containsKey(userId)) {
    return cache[userId]!;
  }
  
  // Fetch from repository
  final repository = ref.read(userRepositoryProvider);
  final user = await repository.getUserById(userId);
  
  // Cache the result
  ref.read(userCacheProvider.notifier).cacheUser(user);
  
  return user;
});
```

### Debounced Search

```dart
final searchQueryProvider = StateProvider<String>((ref) => '');

final debouncedSearchProvider = Provider<String>((ref) {
  final query = ref.watch(searchQueryProvider);
  final debouncer = ref.keepAlive();
  
  Timer? timer;
  timer?.cancel();
  
  timer = Timer(Duration(milliseconds: 500), () {
    debouncer.close();
  });
  
  ref.onDispose(() => timer?.cancel());
  
  return query;
});

final searchResultsProvider = FutureProvider.autoDispose<List<User>>((ref) {
  final query = ref.watch(debouncedSearchProvider);
  
  if (query.isEmpty) return [];
  
  return ref.read(userRepositoryProvider).searchUsers(query);
});
```

### Pagination

```dart
@freezed
class PaginatedState<T> with _$PaginatedState<T> {
  const factory PaginatedState({
    @Default([]) List<T> items,
    @Default(false) bool isLoading,
    @Default(false) bool hasMore,
    @Default(null) String? error,
  }) = _PaginatedState<T>;
}

final userListNotifierProvider = StateNotifierProvider.autoDispose<UserListNotifier, PaginatedState<User>>((ref) {
  return UserListNotifier(ref.read(userRepositoryProvider));
});

class UserListNotifier extends StateNotifier<PaginatedState<User>> {
  final UserRepository _repository;
  int _currentPage = 0;

  UserListNotifier(this._repository) : super(PaginatedState<User>());

  Future<void> loadMore() async {
    if (state.isLoading || !state.hasMore) return;
    
    state = state.copyWith(isLoading: true);
    
    try {
      final newUsers = await _repository.getUsers(page: _currentPage);
      
      state = state.copyWith(
        items: [...state.items, ...newUsers],
        isLoading: false,
        hasMore: newUsers.isNotEmpty,
      );
      
      _currentPage++;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }
}
```

---

## Common Anti-Patterns to Avoid

### ❌ Don't Access Providers in Constructors

```dart
// ❌ Bad
class UserNotifier extends StateNotifier<UserState> {
  UserNotifier(WidgetRef ref) : super(UserState.initial()) {
    // Don't do this!
    final repository = ref.read(userRepositoryProvider);
  }
}

// ✅ Good
final userNotifierProvider = StateNotifierProvider.autoDispose<UserNotifier, UserState>((ref) {
  return UserNotifier(ref.read(userRepositoryProvider));
});
```

### ❌ Don't Use ref.read in build()

```dart
// ❌ Bad
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.read(userProvider); // Won't rebuild!
    return Text(user.name);
  }
}

// ✅ Good
class UserWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(userProvider); // Will rebuild
    return Text(user.name);
  }
}
```

The only exception is reading a provider's notifier inside an `onPressed` or other event handler to call a method on it.

### ❌ Don't Forget `.autoDispose` for Feature-Specific State

For providers that hold state for a specific feature or screen, forgetting `.autoDispose` can lead to memory leaks, as the state will never be cleaned up.

```dart
// ❌ Bad: Memory leak if this is for a screen that can be closed.
final userListProvider = NotifierProvider<UserListNotifier, UserListState>(() {
  return UserListNotifier();
});

// ✅ Good: Auto-disposed when the last listener is removed.
final userListProvider = NotifierProvider.autoDispose<UserListNotifier, UserListState>(() {
  return UserListNotifier();
});
```

### ❌ Don't Overuse `StateProvider`

`StateProvider` is great for simple, local state. For anything involving business logic, asynchronous operations, or complex validation, use a `Notifier` or `AsyncNotifier`.

```dart
// ❌ Bad: Complex state in StateProvider, logic is scattered.
final userStateProvider = StateProvider<Map<String, dynamic>>((ref) => {});

// ✅ Good: Use a Notifier for complex state and logic.
final userNotifierProvider = NotifierProvider<UserNotifier, UserState>(() {
  return UserNotifier();
});
``` 
